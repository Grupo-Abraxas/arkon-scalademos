package training

import cats.effect.{ExitCode, IO, IOApp}
import doobie.implicits._
import doobie.util.transactor.Transactor
import doobie.util.update.Update0



object DoobieDemo extends IOApp {

  implicit class Debugger[A](io:IO[A]){
    def debug: IO[A] = io.map { a =>
      println(s"[${Thread.currentThread().getName}] $a")
      a
    }
  }
  val xa: Transactor[IO] = Transactor.fromDriverManager[IO](
    "org.postgresql.Driver",
    "jdbc:postgresql:mtbMX",
    "userApp",
    "userAppPs"
  )

  case class Estatus(id: Int, description: String)

  def findAllEstatusDescripcion : IO[List[String]] =
    {
      val query =sql"select description from c_estatus".query[String]
      val action = query.to[List]
      action.transact(xa)

    }


  def findAllEstatus : IO[List[Estatus]] =
  {
    val query =sql"select id,  description from c_estatus".query[Estatus]
    val action = query.to[List]
    action.transact(xa)
  }

  def findEstatusById(id : Int) : IO[List[Estatus]] =
  {
    val query =sql"select id,  description from c_estatus where id = $id".query[Estatus]
    val action = query.to[List]
    action.transact(xa)
  }
  def saveEstatus(id : Int ,description: String): IO[Int] = {
    val query = sql"insert into c_estatus (id, description) values ($id, $description)"
    query.update.run.transact(xa)
  }

  def saveEstatusAutoGenerated(description: String): IO[Int] = {
     sql"insert into c_estatus (description) values ($description)"
      .update.withUniqueGeneratedKeys[Int]("id")
      .transact(xa)
  }

  def deleteEstatus(): IO[Int] = {
    val query = sql"delete from c_estatus where id >2 "
    query.update.run.transact(xa)
  }

  override def run(args: List[String]): IO[ExitCode] = {
    findEstatusById(1).debug.as(ExitCode.Success)
    //deleteEstatus.debug.as(ExitCode.Success)

  }
  List(1, 2, 3).flatMap { x =>  List(x, 2 * x, 3 * x) }
  List(1, 2, 3).map { x =>  List(x, 2 * x, 3 * x) }
  val cond: (Int, Int) => Boolean = (x : Int , y : Int) => x<y
  def cond_1 (x: Int ,y : Int):Boolean = { x<y }

  val largerProgram = for {
    a <- sql"select 42".query[Int].unique
    b <- sql"select power(5, 2)".query[Int].unique
  } yield (a, b)

}
